package com.vipin.algorithm.array;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.stream.Collectors;

public class Question2 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String []plan = {".*####", "..#.*#", "###*.#", "#.####", "#.#...", "###..."};
		
		System.out.println(solution(plan));
		
		int n = 1000;
		int m = 1000;
		List<Integer> x = Arrays.asList(522,575,426,445,772,81,447,629,497,202,775,325,982,784,417,156,932,902,728,537,857,
				739,918,211,679,506,340,568,868,16,940,263,593,449,991,310,355,68,431,580,757,218,934,328,
				676,221,80,922,545,511,67,467,674,691,504,835,34,965,980,895,501,152,731,302,153,896,22,489,
				399,607,466,432,502,968,333,475,792,84,10,694,354,712,409,480,643,121,951,492,420,197,925,167,
				717,438,200,986,104,483,620,806,881,858,559,553,554,962,435,279,464,327,549,832,595,720,658,639,992,130,989,958,581,600,473,929,770,455,718,628,807,335,898,552,530,811,569,148,384,954,913,114,315,686,334,382,392,326,8,957,850,231,61,185,588,305,564,890,52,747,943,740,469,370,516,443,7,525,299,412,163,699,571,976,217,590,343,427,220,342,584,239,496,875,601,258,377,40,428,238,517,653,433,768,307,456,878,977,368,999,882,541,826,764,269,401,98,698,763,515,413,495,523,206,357,904,410,844,611,484,262,394,949,107,546,737,987,979,306,685,291,542,134,94,751,89,729,212,964,297,823,280,917,338,176,183,555,3,316,256,13,974,931,24,609,304,151,199,876,825,893,939,374,323,846,819,154,157,814,886,100,856,709,879,479,461,14,123,744,400,20,963,829,984,930,322,665,646,385,191,353,605,110,453,356,243,854,75,831,837,695,845,673,865,524,952,329,331,692,27,63,358,266,801,95,51,478,809,308,499,650,706,822,15,381,267,282,237,119,111,926,444,788,944,702,888,655,521,946,131,616,654,434,683,226,741,486,101,661,532,961,903,276,758,766,259,224,836,54,18,395,56,378,711,83,184,790,945,345,268,785,675,312,321,920,696,
				149,948,535,591,284,82,841,471,103,366,732,776,488,64,736,773,70,122,274,632,560,748,880,889,320,733);
		List<Integer>y = Arrays.asList(345,90,640,212,717,135,211,37,483,144,668,778,256,127,398,808,328,758,
				566,591,371,76,805,964,279,370,309,441,329,125,429,661,241,166,870,394,314,513,901,687,748,614,965,222,122,234,311,997,193,838,172,6,803,711,547,136,442,343,431,420,923,843,239,903,622,535,777,275,321,177,404,261,972,93,747,562,237,698,271,836,504,101,743,433,897,277,110,645,487,324,246,889,524,243,258,961,389,581,789,619,688,477,899,25,913,134,920,179,65,697,727,51,706,763,500,471,68,652,266,850,52,1000,319,411,456,626,115,764,380,517,757,679,801,526,990,967,604,475,416,249,406,199,557,954,355,991,539,505,637,268,254,66,736,428,107,932,332,786,766,868,159,418,768,968,710,905,269,460,802,638,516,806,2,423,326,906,419,721,875,615,755,674,458,111,149,788,378,485,930,577,583,228,657,671,685,151,195,338,546,359,986,147,119,927,528,310,323,294,305,798,399,654,649,20,714,88,735,607,464,417,565,781,216,885,131,437,337,376,454,143,580,618,49,322,413,56,16,636,114,828,741,767,164,966,669,270,646,542,368,925,235,274,350,361,473,106,782,952,142,35,59,709,995,847,974,381,226,224,809,943,527,610,495,298,655,567,790,908,300,633,650,312,582,853,97,881,620,427,240,70,50,178,133,739,533,388,299,558,720,861,922,601,377,882,46,104,9,696,327,585,555,859,963,139,970,860,834,911,876,145,677,214,545,609,879,937,940,553,531,817,994,865,590,886,593,493,221,132,60,623,982,181,64,365,894,175,956,816,126,883,364,352,715,140,335,180,362,874,612,45,520,807,703,613,552,263,351,291,725,774,643,342,719,130,629,953,157,1,40,773,931,678,919,656,434,951,318,430,391,993,823,503,346,854,31,989,851,412,499,819,436,672,571,795,549,554,215,289,19,141,969,15,281,200,835,518,616,783,490,82,285,307,976,933,47,95,812,978,422,797,536,466,936,26,182,589,232,794,333,62,770,397,862,617,611,973,498,873,407,302,296,980,544,864,325,660,550,184,664,443,112,373,448,793,878,822,960,700,926,54,884,220,830,349,447,396,856,353,713,592,537,374,264,18,293,334,173,375,210,635,762,574,387,780,673,356,569,405,386,472,979,120,841,670,800,699,457,639,751,723,408,138,785,124,360,694,915,840,257,121,154,599,863,348,707,39,597,600,938,749,118,959,486,152,659,286,837,680,737,4,247,344,742,728,403,998,935,53,686,548,651,917,410,977,787,958,689,849,772,871,331,731,496,895,7,250,769,445,449,461,702,532,13,236,259,85,918,161,663,627,113,438,867,23,944,10,647,89,921,892,666,759,887,996,372,543,306,888,301,579
);
		
		System.out.println(prison(n, m, x, y));

	}

	public static boolean isValid(String[] plan, boolean[][] visited, int x, int y) {
		return  (x > -1 && x < plan.length) && (y > -1 && y < plan[0].length()) && (plan[x].charAt(y) != '#')
				&& !visited[x][y];
	}

	public static void bfs(String[] plan, boolean[][] visited, int x, int y) {
		int[] dx = { 0, 0, 1, -1 };
		int[] dy = { 1, -1, 0, 0 };

		Queue<Integer> qx = new LinkedList<>();
		Queue<Integer> qy = new LinkedList<>();
		qx.offer(x);
		qy.offer(y);
		while (!qx.isEmpty()) {
			x = qx.poll();
			y = qy.poll();
			for (int i = 0; i < 4; i++) {
				int nx = x + dx[i], ny = y + dy[i];
				if (isValid(plan, visited, nx, ny)) {
					visited[nx][ny] = true;
					qx.offer(nx);
					qy.offer(ny);
				}
			}
		}
	}

	public static int solution(String[] plan) {
		int n = plan.length, m = plan[0].length();
		boolean[][] visited = new boolean[n][m];

		int robots = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (plan[i].charAt(j) == '*' && !visited[i][j]) {
					bfs(plan, visited, i, j);
					robots++;
				}
			}
		}
		return robots;
	}
	
	public static long prison(int n, int m, List<Integer> h, List<Integer> v) {
	    // Write your code here
	    long horizon = 0;
	    long prev = 1;
	    int hSize = h.size();
	    h.sort((x1,y1)->(x1-y1));
	    for(int i=1; i<hSize; i++) {
	        if(h.get(i)-h.get(i-1)==1) {
	            prev++;
	        } else {
	            horizon = Math.max(horizon, prev);
	            prev = 1;
	        }
	    }
	    horizon = Math.max(horizon, prev);
	    v.sort((x1,y1)->(x1-y1));
	    long veritcal = 0;
	    prev = 1;
	    int vSize = v.size();
	    for(int i=1; i<vSize; i++) {
	        if(v.get(i)-v.get(i-1)==1) {
	            prev++;
	        } else {
	            veritcal = Math.max(veritcal, prev);
	            prev = 1;
	        }
	    }
	    veritcal = Math.max(veritcal, prev);
	    return (horizon+1)*(veritcal+1);
	    

	    }


}
class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        ListNode front = new ListNode(0, head);
        ListNode current = front;
        int prefixSum = 0;
        Map<Integer, ListNode> prefixSumToNode = new HashMap<>();
        while (current != null) {
            // Add current's value to the prefix sum
            prefixSum += current.val;

            // If prefixSum is already in  the hashmap, 
            // we have found a zero-sum sequence:
             if (prefixSumToNode.containsKey(prefixSum)) {
                ListNode prev = prefixSumToNode.get(prefixSum);
                current = prev.next;

                // Delete zero sum nodes from hashmap
                // to prevent incorrect deletions from linked list
                int p =  prefixSum + current.val;
                while (p != prefixSum) {
                    prefixSumToNode.remove(p); 
                    current = current.next;
                    p +=  current.val;
                }

                // Make connection from the node before 
                // the zero sum sequence to the node after
                prev.next = current.next;
            } else {
                // Add new prefixSum to hashmap
                prefixSumToNode.put(prefixSum, current);
            }
            // Progress to next element in list
            current = current.next;
        }
        return front.next;
    }
}